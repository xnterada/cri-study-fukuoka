# 第4回 テキスト処理

## 環境変数

システムの設定や動作を制御するための変数です。アプリケーションやシェルが参照できる名前と値のペアで構成されており、システム全体やユーザーセッション全体で共有される情報を格納しています。例えば、ログレベルなどのプログラムの動作設定を環境変数に保持して使用することができます。

環境変数は通常、**大文字**で命名されます。よく使用される環境変数には以下のようなものがあります：

- **`PATH`**: コマンドを検索するディレクトリのリスト
- **`HOME`**: ユーザーのホームディレクトリのパス
- **`USER`**: 現在のユーザー名
- **`SHELL`**: 使用しているシェルのパス

環境変数の値を確認するには、`echo`コマンドと`$`記号を使用します。

```bash
echo $HOME
```

すべての環境変数を一覧表示するには`env`コマンドを使用します。

```bash
env
```

> 📝 **備考**  
> 環境変数は設定ファイル（`.bashrc`、`.profile`など）で定義されることが多く、システム起動時やユーザーログイン時に自動的に読み込まれ、環境変数が設定されます。

### echo

文字列や変数の内容を画面に表示するコマンドです。引数として指定した文字列をそのまま標準出力に表示します。

```bash
echo "Hello, World!"
```

```bash
echo 'こんにちは'
```

変数の内容を表示する場合は、変数名の前に`$`を付けます：

```bash
echo $HOME
```

環境変数を組み合わせて表示することも可能です：

```bash
echo "私のホームディレクトリは $HOME です"
```

`echo`コマンドには便利なオプションがあります：

- **`-n`**: 改行を出力しない
- **`-e`**: エスケープシーケンス(\n、\tなど）を解釈する

```bash
echo -n "改行なし"
```

```bash
echo -e "1行目\n2行目\n3行目"
```

> 💡 **ヒント**  
> シングルクォート（'）とダブルクォート（"）の違いに注意してください。ダブルクォート内では変数が展開されますが、シングルクォート内では文字列として扱われます。

## 標準入力・標準出力・標準エラー出力

Linuxのプロセスには3つの標準的な入出力ストリームがあります。これらはプロセス間でのデータのやり取りを行う仕組みです。

### 標準入力（stdin）

プログラムがデータを受け取る入力源です。通常はキーボードからの入力になります。ファイルディスクリプタ番号は**0**です。

### 標準出力（stdout）

プログラムが正常な結果を出力する出力先です。通常は画面（ターミナル）に表示されます。ファイルディスクリプタ番号は**1**です。

### 標準エラー出力（stderr）

プログラムがエラーメッセージを出力する出力先です。通常は画面に表示されますが、標準出力とは区別されます。ファイルディスクリプタ番号は**2**です。

> ℹ️ **情報**  
> ファイルディスクリプタは、プロセスが開いているファイルやストリームを識別するための番号です。0、1、2はそれぞれ標準入力、標準出力、標準エラー出力として予約されています。

## リダイレクト

標準入力、標準出力、標準エラー出力を別の場所（主にファイル）に転送する機能です。コマンドの出力をファイルに保存したり、ファイルの内容をコマンドの入力として使用したりできます。

### 出力リダイレクト（>）

標準出力をファイルに書き込みます。ファイルが存在しない場合は新規作成され、ファイルが存在する場合は上書きされます。作業用ディレクトリに移動して`ls -l`コマンドの結果を新規ファイルに保存してみましょう。

```bash
cd ~/cri-study-linux-workspace
ls -l > file_list.txt
```

後ほど説明しますが、`cat`コマンドでファイルの内容を確認できます。

```bash
cat file_list.txt
```

### 追記リダイレクト（>>）

標準出力をファイルに追記します。ファイルが存在しない場合は新規作成され、ファイルが存在する場合は末尾に追加されます。

新規作成または上書き：

```bash
echo "1行目" > log.txt
```

確認：

```bash
cat log.txt
```

追記：

```bash
echo "2行目" >> log.txt
```

再度確認：

```bash
cat log.txt
```

ここで、通常のリダイレクト`>`を行うと、ファイルの内容が上書きされます。

```bash
echo -e "3行目\n7行目\n5行目\n4行目" > log.txt
```

再度確認：

```bash
cat log.txt
```

> ⚠️ **注意**  
> `>`でリダイレクトする際、ファイルが存在する場合は内容が完全に上書きされます。既存の内容を保持したい場合は`>>`を使用してください。

### 入力リダイレクト（<）

ファイルの内容を標準入力として使用します。

log.txtの内容を並び替え（ソート）：

```bash
sort < log.txt
```

log.txtの行数・単語数・文字数（バイト数）をカウント：

```bash
wc < log.txt
```

> ℹ️ **情報**  
> 出力は「 4 4 32」となるはずです。「 4 4 12」と期待していたのであれば、それは誤りです。コンピューターでは漢字は3バイトで表現されるため、文字数（バイト数）が異なります。

### エラーリダイレクト（2>）

標準エラー出力をファイルにリダイレクトします。

エラーをファイルに出力：

```bash
ls file8.txt 2> error.txt
```

`file8.txt`は存在しないため、エラーメッセージがerror.txtに出力されます。

`error.txt`の内容を確認：

```bash
cat error.txt
```

エラーを破棄：

```bash
ls file9.txt 2> /dev/null
```

`/dev/null`は特別なデバイスファイルで、書き込まれたデータはすべて破棄されます。

> 💡 **ヒント**  
> `/dev/null`は「出力は要らないが処理だけ走らせたい」「エラーや冗長なメッセージを消したい」場面で使います。

### 標準出力とエラーをまとめてリダイレクト（&>）

標準出力と標準エラー出力を同じファイルにリダイレクトします。

`file10.txt`が存在してもしなくてもエラーも含めて出力：

```bash
ls file10.txt &> all_output.txt
```

## テキスト処理

Linuxには、テキストファイルの内容を表示、検索、操作するための多くのコマンドがあります。これらのコマンドを組み合わせることで、効率的にテキスト処理を行うことができます。

### cat（concatenate）

ファイルの内容を画面に表示するコマンドです。複数のファイルを連結して表示することも可能です。

ファイルの内容を表示：

```bash
cat file_list.txt
```

複数ファイルを連結して表示：

```bash
cat log.txt error.txt
```

> 💡 **ヒント**  
> 大きなファイルの場合、`cat`ですべての内容が一度に表示されてしまいます。行数の多い長いファイルを表示する場合は`less`コマンドが適しています。

### head

ファイルの先頭部分を表示するコマンドです。デフォルトでは先頭10行が表示されます。まずは10行以上の行を含むファイルを用意しましょう。

```bash
ls -l / > root_list.txt
```

内容を確認：

```bash
cat root_list.txt
```

これはルートディレクトリ`/`直下のファイル・ディレクトリ一覧です。`head`コマンドでは指定がなければ先頭10行が表示されます。

先頭10行を表示：

```bash
head root_list.txt
```

先頭5行を表示：

```bash
head -n 5 root_list.txt
```

### tail

ファイルの末尾部分を表示するコマンドです。デフォルトでは末尾10行が表示されます。ログファイルの監視などでよく使用されます。

末尾10行を表示：

```bash
tail root_list.txt
```

末尾5行を表示：

```bash
tail -n 5 root_list.txt
```

ファイルの更新をリアルタイムで監視：

```bash
tail -f log.txt
```

`-f`オプション（follow）はファイルに新しい行が追加されるとリアルタイムで表示されます。ログファイルの監視に非常に便利です。

> 💡 **ヒント**  
> `tail -f`を終了するには`Ctrl+C`を押します。このコマンドに限らず、ほとんどのコマンドは`Ctrl+C`で強制終了できます（MacBookでは`Command+C`）

### wc（word count）

ファイルの行数、単語数、文字数（バイト数）をカウントするコマンドです。

行数、単語数、文字数（バイト数）を表示：

```bash
wc log.txt
```

行数のみを表示：

```bash
wc -l log.txt
```

単語数のみを表示：

```bash
wc -w log.txt
```

文字数（バイト数）のみを表示：

```bash
wc -c log.txt
```

### マルチバイト文字

日本語などのマルチバイト文字を含むファイルの場合、`wc -c`で表示される文字数はバイト数になります。例えば、漢字1文字は3バイトで表現されるため、実際の文字数とは異なる場合があります。

- **1バイト**: 半角英数字1文字
- **2バイト**: ひらがな・カタカナ1文字
- **3バイト**: 漢字1文字
- **4バイト以上**: 一部の絵文字や特殊文字

### grep（global regular expression print）

ファイル内で指定したパターン（文字列や正規表現）にマッチする行を検索・表示するコマンドです。テキスト検索でよく使用されます。

指定した文字列を含む行を表示：

```bash
grep "dir" file_list.txt
```

指定した文字列を含まない行を表示：

```bash
grep -v "dir" file_list.txt
```

> ℹ️ **情報**  
> grepは正規表現もサポートしており、より複雑なパターンマッチングが可能です。正規表現については、本カリキュラムでは扱いません。

### sed（stream editor）

テキストの置換、削除、挿入などを行うストリームエディタです。ファイルを直接編集せずに、テキストの変換を行うことができます。

各行で最初にマッチした部分のみ置換：

```bash
sed 's/dir/file/' file_list.txt
```

これにより、**各行で**「dir」が最初にマッチした部分のみ「file」に置換されます。

> 💡 **ヒント**  
> 各行で1度だけでなく、すべてのマッチを置換したい場合は、末尾に`g`を付けて、`'s/dir/file/g'`のようにします。

3行目を削除：

```bash
sed '3d' file_list.txt
```

2行目から4行目を削除：

```bash
sed '2,4d' file_list.txt
```

1行目から4行目のみを表示：

```bash
sed -n '1,4p' file_list.txt
```

> ℹ️ **情報**  
> これらの操作では直接ファイルを編集しているのではなく、標準出力に結果を表示しているだけの動作になります。

ファイルを直接編集（インプレース編集）するには、`-i`オプションを使用します。まずは置換前の内容を確認しましょう。

```bash
cat file_list.txt
```

ファイル内のすべての「dir」を「file」に置換して直接編集：

```bash
sed -i 's/dir/file/g' file_list.txt
```

編集後の内容を確認：

```bash
cat file_list.txt
```

> ⚠️ **注意**  
> `-i`オプションによるインプレース編集は元のファイルを直接変更します。重要なファイルの場合は事前にバックアップを作成することをお勧めします。

### そのほかのテキスト処理コマンド

Linuxには他にも多くのテキスト処理コマンドがあります。ここでは代表的なものを紹介します。

- **less**: 大きなテキストファイルをページ単位で表示するコマンドです。スクロールや検索が可能で、長いファイルの閲覧や文字列検索に便利です。
- **awk**: テキストデータの処理や分析に特化したプログラミング言語・コマンドです。列（フィールド）ベースのデータ処理が得意で、CSVファイルやログファイルの処理によく使用されます。
- **cut**: テキストファイルの特定の列やフィールドを抽出するコマンドです。区切り文字を指定して、必要な部分だけを取り出すことができます。
- **sort**: テキストファイルの行を並び替えるコマンドです。アルファベット順や数値順、逆順など、さまざまな条件でソートが可能です。
- **uniq**: 連続する重複行を削除するコマンドです。主に`sort`コマンドと組み合わせて使用されます。

## パイプ（|）

コマンドの**標準出力**を別のコマンドの標準入力として渡す機能です。複数のコマンドを連結して、複雑なデータ処理を効率的に行うことができます。

> ⚠️ **注意**  
> パイプで渡されるのは標準出力のみです。標準エラー出力はパイプでは渡されず、そのまま画面に表示されます。

ファイル一覧からtxtファイルのみを抽出：

```bash
ls -l | grep ".txt"
```

ファイルの行数をカウント：

```bash
cat root_list.txt | wc -l
```

リダイレクトとコマンドを連結して使用することも可能です。

```bash
cat file_list.txt | grep ".txt" > text_files.txt
```

lsコマンドで出力したファイルをxargsコマンドとrmコマンドを組み合わせて削除することも可能です。

```bash
ls *.txt | xargs rm
```

これにより、カレントディレクトリ内のすべての`.txt`ファイルが削除されます。

> 💡 **ヒント**  
> `xargs`コマンドは標準入力から受け取ったデータを引数として他のコマンドに渡すためのコマンドです。本カリキュラムでは詳しい説明はしませんが、パイプを利用して複数のコマンドを連結する際によく使用されます。

### 標準エラー出力とパイプ

存在しないファイルにアクセスしようとした場合は以下のようになります。

```bash
cat file11.txt | grep "No such file"
```

```
cat: file11.txt: No such file or directory
```

この場合、エラーメッセージは画面に表示されますが、`grep`コマンドには何も渡されません。標準エラー出力もパイプで渡したい場合は、事前にリダイレクトして標準出力と統合する必要があります。

```bash
cat file11.txt 2>&1 | grep "No such file"
```

`grep`コマンドに渡された文字列は、`cat`コマンドではエラー出力でしたが、標準出力として扱われます。そのため出力リダイレクト`>`を使用してファイルに書き込むことができます。

```bash
cat file11.txt 2>&1 | grep "No such file" > file12.txt
```

## おわりに

コマンドとパイプ、リダイレクトを組み合わせた使用は実際の業務で頻繁に使用されます。しっかりと習得しておきましょう。
